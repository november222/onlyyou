import { supabase } from '@/lib/supabase';
import type { Session } from '@supabase/supabase-js';
import * as WebBrowser from 'expo-web-browser';
import * as AuthSession from 'expo-auth-session';
import Constants from 'expo-constants';
import { Platform } from 'react-native';

WebBrowser.maybeCompleteAuthSession();

export interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  premiumTier: 'free' | 'monthly' | 'yearly' | 'lifetime';
  premiumExpiresAt?: string | null;
}

export interface AuthState {
  isAuthenticated: boolean;
  user: User | null;
  isLoading: boolean;
}

class AuthService {
  private authState: AuthState = {
    isAuthenticated: false,
    user: null,
    isLoading: true,
  };

  public onAuthStateChange: ((state: AuthState) => void) | null = null;

  private initialized = false;

  private getRedirectUrl(): string {
    if (Platform.OS === 'web') {
      if (typeof window !== 'undefined' && window.location) {
        return `${window.location.protocol}//${window.location.host}/auth/callback`;
      }
      return '/auth/callback';
    }
    if (Constants?.appOwnership === 'expo') {
      const proxy = AuthSession.makeRedirectUri({ useProxy: true, path: 'auth/callback' });
      // Some environments may still return exp:// — prefer the https proxy root
      if (proxy.startsWith('exp://')) return 'https://auth.expo.dev';
      return proxy;
    }
    return 'onlyyou://auth/callback';
  }

  public async init(): Promise<void> {
    if (this.initialized) return;
    this.initialized = true;

    supabase.auth.onAuthStateChange((event, session) => {
      console.log('Auth event:', event);

      if ((event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') && session) {
        setTimeout(() => {
          this.handleSessionChange(session!).catch((err) => {
            console.error('Auth handler failed:', err);
            this.updateAuthState({ isLoading: false });
          });
        }, 0);
      }

      if (event === 'SIGNED_OUT') {
        this.updateAuthState({ isAuthenticated: false, user: null, isLoading: false });
      }
    });

    const { data: { session } } = await supabase.auth.getSession();
    if (session) {
      await this.handleSessionChange(session);
    } else {
      this.updateAuthState({ isLoading: false });
    }
  }

  private async handleSessionChange(session: Session): Promise<void> {
    try {
      const { data: profile, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', session.user.id)
        .maybeSingle();

      if (error) {
        console.error('Failed to fetch user profile:', error);
        this.updateAuthState({ isLoading: false });
        return;
      }

      if (!profile) {
        const { data: created, error: insertError } = await supabase
          .from('users')
          .insert({
            id: session.user.id,
            email: (session.user as any).email || '',
            full_name:
              ((session.user as any).user_metadata?.full_name as string) ||
              ((session.user as any).email as string) ||
              'User',
            avatar_url: ((session.user as any).user_metadata?.avatar_url as string) || null,
            premium_tier: 'free',
            premium_expires_at: null,
          })
          .select('*')
          .maybeSingle();

        if (insertError || !created) {
          console.error('Failed to create user profile:', insertError);
          this.updateAuthState({ isLoading: false });
          return;
        }

        const user: User = {
          id: created.id,
          email: created.email,
          name: created.full_name || created.email,
          avatar: created.avatar_url || undefined,
          premiumTier: created.premium_tier,
          premiumExpiresAt: created.premium_expires_at,
        };
        this.updateAuthState({ isAuthenticated: true, user, isLoading: false });
        return;
      }

      const user: User = {
        id: profile.id,
        email: profile.email,
        name: profile.full_name || profile.email,
        avatar: profile.avatar_url || undefined,
        premiumTier: profile.premium_tier,
        premiumExpiresAt: profile.premium_expires_at,
      };

      this.updateAuthState({ isAuthenticated: true, user, isLoading: false });
    } catch (error) {
      console.error('Error handling session change:', error);
      this.updateAuthState({ isLoading: false });
    }
  }

  private updateAuthState(updates: Partial<AuthState>) {
    this.authState = { ...this.authState, ...updates };
    const snapshot = this.authState;
    if (this.onAuthStateChange) {
      setTimeout(() => {
        try { this.onAuthStateChange?.(snapshot); } catch (err) { console.error('Auth state listener error:', err); }
      }, 0);
    }
  }

  private extractOAuthTokens(url: string): { accessToken: string; refreshToken: string } | null {
    try {
      const parsedUrl = new URL(url);
      let accessToken = parsedUrl.searchParams.get('access_token');
      let refreshToken = parsedUrl.searchParams.get('refresh_token');
      if ((!accessToken || !refreshToken) && parsedUrl.hash) {
        const hash = parsedUrl.hash.startsWith('#') ? parsedUrl.hash.slice(1) : parsedUrl.hash;
        const hashParams = new URLSearchParams(hash);
        accessToken = accessToken || hashParams.get('access_token');
        refreshToken = refreshToken || hashParams.get('refresh_token');
      }
      if (accessToken && refreshToken) return { accessToken, refreshToken };
    } catch (error) {
      console.error('Failed to parse OAuth callback URL:', error);
    }
    return null;
  }

  public getAuthState(): AuthState { return this.authState; }
  public getCurrentUser(): User | null { return this.authState.user; }
  public isAuthenticated(): boolean { return this.authState.isAuthenticated; }

  // Email/password is not used. Google OAuth only per product requirements.

  public async signOut(): Promise<void> {
    try {
      this.updateAuthState({ isLoading: true });
      const { error } = await supabase.auth.signOut();
      if (error) throw error;
      this.updateAuthState({ isAuthenticated: false, user: null, isLoading: false });
    } catch (error) {
      console.error('Sign out failed:', error);
      this.updateAuthState({ isLoading: false });
      throw new Error('Đăng xuất thất bại. Vui lòng thử lại.');
    }
  }

  public async updateProfile(updates: { name?: string; avatar?: string }): Promise<void> {
    try {
      if (!this.authState.user) throw new Error('Not authenticated');
      const { error } = await supabase
        .from('users')
        .update({ full_name: updates.name, avatar_url: updates.avatar })
        .eq('id', this.authState.user.id);
      if (error) throw error;
      this.updateAuthState({ user: this.authState.user ? { ...this.authState.user, name: updates.name || this.authState.user.name, avatar: updates.avatar || this.authState.user.avatar } : null });
    } catch (error) {
      console.error('Update profile failed:', error);
      throw new Error('Cập nhật hồ sơ thất bại. Vui lòng thử lại.');
    }
  }

  public async signInWithGoogle(): Promise<boolean> {
    let success = false;
    try {
      this.updateAuthState({ isLoading: true });
      const redirectUrl = this.getRedirectUrl();
      console.log('Auth (Google) redirectUrl:', redirectUrl);
      const { data, error } = await supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: redirectUrl, skipBrowserRedirect: Platform.OS !== 'web' } });
      if (error) throw error;
      if (Platform.OS === 'web') { this.updateAuthState({ isLoading: false }); return true; }
      if (!data?.url) throw new Error('Không nhận được URL xác thực Google.');
      let result: any;
      const hasStartAsync = typeof (AuthSession as any)?.startAsync === 'function';
      if (Constants?.appOwnership === 'expo' && hasStartAsync) {
        result = await (AuthSession as any).startAsync({ authUrl: data.url, returnUrl: redirectUrl as any });
      } else {
        result = await WebBrowser.openAuthSessionAsync(data.url, redirectUrl);
      }
      if (result.type !== 'success' || !result.url) { if (result.type === 'dismiss' || result.type === 'cancel') throw new Error('Đã hủy đăng nhập Google.'); throw new Error('Đăng nhập Google không hoàn tất.'); }
      const url = result.url as string;
      let authCode: string | null = null; try { const parsed = AuthSession.parse(url); authCode = (parsed as any)?.params?.code || null; } catch {}
      if (!authCode) { try { const u = new URL(url); authCode = u.searchParams.get('code'); } catch {} }
      if (authCode) { const { data: sessionData, error: exErr } = await supabase.auth.exchangeCodeForSession({ authCode }); if (exErr) throw exErr; if (!sessionData?.session) throw new Error('Không tạo được phiên Google.'); await this.handleSessionChange(sessionData.session); success = true; return true; }
      const tokens = this.extractOAuthTokens(url); if (!tokens) throw new Error('Không nhận được token từ Google.'); const { data: setData, error: setErr } = await supabase.auth.setSession({ access_token: tokens.accessToken, refresh_token: tokens.refreshToken } as any); if (setErr || !setData?.session) throw (setErr || new Error('Không tạo được phiên Google.')); await this.handleSessionChange(setData.session); success = true; return true;
    } catch (error: any) { console.error('Google sign in failed:', error); if (!success) this.updateAuthState({ isLoading: false }); throw new Error(error?.message || 'Đăng nhập Google thất bại. Vui lòng thử lại.'); }
  }

  // Apple Sign-In removed (Google only)

  // No reset password flow since email/password auth is disabled

  public async isPremium(): Promise<boolean> {
    if (!this.authState.user) return false;
    const tier = this.authState.user.premiumTier; if (tier === 'free') return false;
    if (this.authState.user.premiumExpiresAt) return new Date(this.authState.user.premiumExpiresAt) > new Date();
    return true;
  }
}

export default new AuthService();

